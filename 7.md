- Python 如何计算装饰器句法
  
```python
@decorate
def target():    
    print('running target()')
```
上述代码的效果与下述写法一样:
```python
def target():    
    print('running target()')
    target = decorate(target)
```

- Python 如何判断变量是不是局部的

Python 编译函数的定义体时，它判断b是局部变量，因为在函数中给它赋值了。生成的字节码证实了这种判断，Python 会尝试从本地环境获取b。后面调用f2(3)时，f2的定义体会获取并打印局部变量a的值，但是尝试获取局部变量b的值时，发现b没有绑定值

- 闭包存在的原因和工作原理

闭包指`延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。`

```python
def make_averager():    
    ################################闭包
    series = [] #自由变量   
    def averager(new_value):        
        series.append(new_value)        
        total = sum(series)        
        return total/len(series)  
    #################################  
    return averager
```
综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。

*注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。*

- nonlocal 能解决什么问题

对数字、字符串、元组等不可变类型来说，只能读取，不能更新。如果尝试重新绑定，例如`count = count + 1`，其实会隐式创建局部变量`count`。这样，`count`就不是自由变量了，因此不会保存在闭包中。

为了解决这个问题，Python 3 引入了`nonlocal`声明。它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为`nonlocal`声明的变量赋予新值，闭包中保存的绑定会更新。

- 实现行为良好的装饰器

- 标准库中有用的装饰器
1. functools.lru_cache
2. functools.singledispatch

- 实现一个参数化装饰器

解析源码中的装饰器时，Python 把被装饰的函数作为第一个参数传给装饰器函数。那怎么让装饰器接受其他参数呢？答案是：创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰的函数上。

例如:

```python
registry = set()  
def register(active=True):  
    def decorate(func): 
        print('running register(active=%s)>decorate(%s)' % (active, func))        
        if active:
            registry.add(func)   
        else:            
            registry.discard(func)
       return func
    return decorate  
@register(active=False)  
def f1():    
    print('running f1()')

@register()  
def f2():    
    print('running f2()')def f3():    
    print('running f3()')
```
装饰器做了什么：`这是装饰器的典型行为：把被装饰的函数替换成新函数，二者接受相同的参数，而且（通常）返回被装饰的函数本该返回的值，同时还会做些额外操作。`


