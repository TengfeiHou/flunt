这一章接续第 1 章，说明如何实现在很多 Python 类型中常见的特殊方法。

- 支持用于生成对象其他表示形式的内置函数（如repr()、bytes()，等等）
- 使用一个类方法实现备选构造方法
- 扩展内置的format()函数和str.format()方法使用的格式微语言
- 实现只读属性
- 把对象变为可散列的，以便在集合中及作为dict的键使用
- 利用__slots__节省内存11

同时讨论

- 何以及何时使用@classmethod和@staticmethod装饰器
- Python 的私有属性和受保护属性的用法、约定和局限


通过案例`开发一个简单的二维欧几里得向量类型`

## 对象表示方法

||||
|:-:|:-:|:-:|
|repr()|\_\_repr\_\_|便于开发者理解的方式返回对象的字符串表示形式（直接输出实例，eval()）|
|str()|\_\_str\_\_|便于用户理解的方式返回对象的字符串表示形式（print调用）|
|bytes()|\_\_bytes\_\_|获取对象的字节序列表示形式|
|format()  str.format()|\_\_format\_\_|特殊的格式代码显示对象的字符串表示形式|


## 向量类

```python
from array import array
import math
class Vector2d:    
    typecode = 'd' #1
    
    def __init__(self, x, y):        
        self.x = float(x) #2
        self.y = float(y)    
    
    def __iter__(self):        
        return (i for i in (self.x, self.y)) #3
    
    def __repr__(self):        
        class_name = type(self).__name__        return '{}({!r}, {!r})'.format(class_name, *self) #4
    
    def __str__(self):        
        return str(tuple(self)) #5
    
    def __bytes__(self):        
        return (bytes([ord(self.typecode)]) #6
         + bytes(array(self.typecode, self))) #7
    
    def __eq__(self, other):        
        return tuple(self) == tuple(other) #8
    
    def __abs__(self):        
        return math.hypot(self.x, self.y) #9
    
    def __bool__(self):        
        return bool(abs(self)) #10
```


## `classmethod`与`staticmethod`

`classmethod`最常见的用途是定义备选构造方法

`staticmethod`装饰器也会改变方法的调用方式，但是第一个参数不是特殊的值。其实，静态方法就是普通的函数，只是碰巧在类的定义体中，而不是在模块层定义。

> `*args`的用法:`*args`和`**kwargs`主要用于函数定义。 你可以将不定数量的参数传递给一个函数。`*args` 是用来发送一个非键值对的可变数量的参数列表给一个函数.

> `**kwargs` 的用法: `**kwargs` 允许你将不定长度的键值对, 作为参数传递给一个函数。 如果你想要在一个函数里处理带名字的参数, 你应该使用`**kwargs`。


## 格式化显示

格式规范微语言为一些内置类型提供了专用的表示代码。比如，b和x分别表示二进制和十六进制的int类型，f表示小数形式的float类型，而%表示百分数形式

具体见[format python文档](https://docs.python.org/zh-cn/3/library/string.html#formatspec)

如何拓展格式规范微语言：\_\_format\_\_函数中的fmt\_spec参数进行分析。

## 可散列 \_\_hash\_\_

先使xy坐标不可变 利用`@property`

再重写hash函数

```python
def __hash__(self):    
    return hash(self.x) ^ hash(self.y
```

> 想创建可散列的类型，不一定要实现特性，也不一定要保护实例属性。只需正确地实现\_\_hash\_\_和\_\_eq\_\_方法即可。但是，实例的散列值绝不应该变化，因此我们借机提到了只读特性。

## python私有属性

双下划线：如果以__mood的形式（两个前导下划线，尾部没有或最多有一个下划线）命名实例属性，Python 会把属性名存入实例的__dict__属性中，而且会在前面加上一个下划线和类名。因此，对Dog类来说，__mood会变成_Dog__mood；对Beagle类来说，会变成_Beagle__mood。这个语言特性叫名称改写（name mangling）

单下划线：Python 解释器不会对使用单个下划线的属性名做特殊处理，不过这是很多 Python 程序员严格遵守的约定，他们不会在类外部访问这种属性。遵守使用一个下划线标记对象的私有属性很容易，就像遵守使用全大写字母编写常量那样容易。 *不过在模块中，顶层名称使用一个前导下划线的话，的确会有影响：对from mymodimport *来说，mymod中前缀为下划线的名称不会被导入。*

## \_\_Slots\_\_

节省内存

## 覆盖类属性




