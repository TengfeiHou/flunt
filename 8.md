# 对象引用、可变性和垃圾回收


## 标识、相等性和别名

### 变量相等 和相同变量

### 元组的相对不变性

> str、bytes和array.array等单一类型序列是扁平的，它们保存的不是引用，而是在连续的内存中保存数据本身（字符、字节和数字

元组是`相对不可变性`
```python
t1 = (1,2,[30,40])
t2 = (1,2,[30,40])
print(id(t1),id(t2))
print(t1 == t2)

print(id(t1[0]),id(t1[1]),id(t1[2]))
t1[-1].append(88)
print(id(t1[0]),id(t1[1]),id(t1[2]))

print(id(t1),id(t2))
print(t1 == t2)

# tuple中含有list就不能hash
# 下面这句话就会报错
#d = {t1:1}

```

## 浅复制和深复制

构造方法或[:]做的是浅复制（即复制了最外层容器，副本中的元素是源容器中元素的引用）。

> 对元组来说，+=运算符创建一个新元组，然后重新绑定给变量

## 函数的参数作为引用时

Python 唯一支持的参数传递模式是共享传参

共享传参指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。这种方案的结果是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识（即不能把一个对象替换成另一个对象）


**不要用可变参数作为函数的默认参数**，这样会让可变参数在每次实例化的时候如果不给值都默认指向一个可变参数。所以**通常使用None作为接收可变值的参数的默认值**。


## del和垃圾回收

## 弱引用

弱引用不会增加对象的引用数量。引用的目标对象称为所指对象（referent）。因此我们说，弱引用不会妨碍所指对象被当作垃圾回收。

- `WeakValueDictionary`：值弱引用
- `WeakKeyDictionary`：键弱引用


## 总结

就是python变量不是实际的内存中的值，而是内存地址（引用）
1. 简单的赋值不创建副本。
2. 对+=或*=所做的增量赋值来说，如果左边的变量绑定的是不可变对象，会创建新对象；如果是可变对象，会就地修改。
3. 为现有的变量赋予新值，不会修改之前绑定的变量。这叫重新绑定：现在变量绑定了其他对象。如果变量是之前那个对象的最后一个引用，对象会被当作垃圾回收。
4. 函数的参数以别名的形式传递，这意味着，函数可能会修改通过参数传入的可变对象。这一行为无法避免，除非在本地创建副本，或者使用不可变对象（例如，传入元组，而不传入列表）。
5. 使用可变类型作为函数参数的默认值有危险，因为如果就地修改了参数，默认值也就变了，这会影响以后使用默认值的调用。



