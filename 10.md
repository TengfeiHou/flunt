# 序列的修改、散列和切片

继续编写vector使其变成多维向量，并具备以下功能：
- 基本的序列协议—— __len__和__getitem__
- 正确表述拥有很多元素的实例
- 适当的切片支持，用于生成新的Vector实例
- 综合各个元素的值计算散列值
- 自定义的格式语言扩展

## 序列协议

> 在 Python 中创建功能完善的序列类型无需使用继承，只需实现符合序列协议的方法

在面向对象编程中，`协议是非正式的接口`，只在文档中定义，在代码中不定义。例如，Python 的序列协议只需要 **\_\_len\_\_()** 和 **\_\_getitem\_\_()** 两个方法。任何类（如Spam），只要使用标准的签名和语义实现了这两个方法，就能用在任何期待序列的地方。Spam是不是哪个类的子类无关紧要，只要提供了所需的方法即可

*我们说它是序列，因为它的行为像序列，这才是重点*

`slice`作为内置类型 可以用来切片

一般切片方法：

```python
class Vector:   
    # 省略了很多行    
    # # ...    
    def __len__(self):        
        return len(self._components)  

    def __getitem__(self, index):        
        return self._components[index]
```

利用slice实现完美切片方法：

```python
def __len__(self):       
    return len(self._components)    
    
def __getitem__(self, index):        
    cls = type(self)  #➊        
    if isinstance(index, slice):  #➋             
        return cls(self._components[index])  #➌        
    elif isinstance(index, numbers.Integral):#  ➍            
        return self._components[index]  #➎ 
    else:            
        msg = '{cls.__name__} indices must be integers'            
        raise TypeError(msg.format(cls=cls))
```

## 动态存取属性

1. getattr
2. setattr


## 散列和快速等值测试

`functools.reduce()`函数：Apply function of two arguments cumulatively to the items of iterable, from left to right, so as to reduce the iterable to a single value. 
For example, reduce`(lambda x, y: x+y, [1, 2, 3, 4, 5])` calculates `((((1+2)+3)+4)+5)`.

导入`functools`和`operator`之后，`hash`函数写作：

```python
def __hash__(self):    
    hashes = map(hash, self._components)    
    return functools.reduce(operator.xor, hashes)
``` 

> zip函数的名字取自拉链系结物（zipper fastener），因为这个物品用于把两个拉链边的链牙咬合在一起，这形象地说明了zip(left, right)的作用。zip函数与文件压缩没有关系。*zip有个奇怪的特性：当一个可迭代对象耗尽后，它不发出警告就停止*

## 格式化

[扩展格式规范微语言](https://docs.python.org/3/library/string.html#formatspec)时，最好避免重用内置类型支持的格式代码。这里对微语言的扩展还会用到浮点数的格式代码`eEfFgGn%`，而且保持原意，因此绝对要避免重用代码。整数使用的格式代码有`bcdoxXn`，字符串使用的是`s`。在Vector2d类中，我选择使用`p`表示极坐标。使用`h`表示超球面坐标（hyperspherical coordinate）是个不错的选择


## tips:

python除了init里面定义self以外 在类内和类方法外定义的局部变量都属于self

```python
class A:
    aa = 1

    def pr(self):
        print(self)

class B:
    def __init__(self):
        self.aa = 1
    
    def pr(self):
        print(self)

a = A()
b = A()

print(a.aa)
print(b.aa)

print(dir(a))
print(dir(b))
```


